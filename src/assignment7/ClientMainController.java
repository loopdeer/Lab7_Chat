package assignment7;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.scene.Cursor;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.SplitPane;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TextField;
import javafx.scene.control.Tooltip;
import javafx.scene.image.ImageView;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.scene.text.TextFlow;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;

import javafx.scene.media.Media;
import javafx.scene.media.MediaPlayer;
import com.uz.emojione.Emoji;
import com.uz.emojione.EmojiOne;
import com.uz.emojione.fx.ImageCache;

import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;

import javafx.scene.control.TextArea;

import javafx.event.Event;

public class ClientMainController {
	//@FXML
	//private TextArea viewArea;
	@FXML
	private VBox viewTextFlow;
	@FXML
	private TextField messageBox;
	@FXML
	private TextField groupTextField;
	@FXML
	private Button sendButton;
	@FXML
	private TextArea viewAreaGroup;
	@FXML
	private Button addressButton;
	@FXML
	private TextField addressBox;
	@FXML
	private Button groupSendButtton;
	@FXML
	private Tab startTab;
	@FXML
	private TabPane chatTabPane;
	@FXML
	private TextArea userList;
	@FXML
	private Tab onlineTab;
	@FXML
	private ScrollPane scrollText;
	@FXML
	private TextField emojiText;
	@FXML
	private TextFlow emojiSearchFlow;
	@FXML
	private AnchorPane emojiPane;
	@FXML
	private SplitPane mainSplit;
	@FXML
	private ChoiceBox emojiCategory;
	
	@FXML
	void initialize()
	{
		scrollText.vvalueProperty().bind(viewTextFlow.heightProperty());
		mainSplit.getItems().remove(emojiPane);
		emojiCategory.getItems().addAll(EmojiOne.getInstance().getCategories());
		emojiCategory.getSelectionModel().selectedIndexProperty().addListener(new ChangeListener<Number>(){

			
			@Override
			public void changed(ObservableValue<? extends Number> observable, Number oldValue, Number newValue) {
				// TODO Auto-generated method stub
				emojiSearch(categories.get(newValue.intValue()));
			}
			});
		
		emojiText.textProperty().addListener(new ChangeListener<String>(){

			@Override
			public void changed(ObservableValue<? extends String> arg0, String arg1, String arg2) {
				// TODO Auto-generated method stub
				emojiSearch(categories.get(emojiCategory.getSelectionModel().getSelectedIndex()));
			}
			
		});
	}
	private String groupName;
	private boolean inGroup;
	private TextArea mainArea;
	private PrintWriter writer;
	private TextField mainTextField;
	private HashMap<String, ChatTabController> chats = new HashMap<String, ChatTabController>();
	private String currentSelected;
	private boolean firstRun = true;
	private List<String> categories;
	private VBox mainTextFlow;
	private Map<String, List<Emoji>> allEmojis;
	
	public ClientMainController(PrintWriter w)
	{
		writer = w;
		mainTextFlow = viewTextFlow;
		mainTextField = messageBox;
		inGroup = false;
		currentSelected = "*DEFAULT*";
		//chats.put("*DEFAULT*", startTab);
		categories = EmojiOne.getInstance().getCategories();
		allEmojis = EmojiOne.getInstance().getCategorizedEmojis(0);
	}
	
	@FXML
	public void openEmojis(Event event)
	{
		
		if(mainSplit.getItems().indexOf(emojiPane) == -1)
		{
			mainSplit.getItems().add(emojiPane);
			
			mainSplit.setDividerPosition(0, 0.75); 
		}
		else
			mainSplit.getItems().remove(emojiPane);
	}
	
	// Event Listener on Tab.onSelectionChanged
	@FXML
	public void allSelected(Event event) {
		// TODO Autogenerated
		mainTextFlow = viewTextFlow;
		mainTextField = messageBox;
		currentSelected = "*DEFAULT*";
		inGroup = false;
	}
	// Event Listener on Button[#sendButton].onAction
	@FXML
	public void sendMessage(ActionEvent event) {
		// TODO Autogenerated
		
		Scanner commandChecker = new Scanner(mainTextField.getText());
		if(commandChecker.next().equals(ChatClient.COMMANDSTART))
		{
			addTextTextFlow(viewTextFlow, "Do not start messages with " + ChatClient.COMMANDSTART + "\n", scrollText, null, null);
			return;
		}
		
		if(inGroup)
		{
			if(groupName == null)
				mainArea.appendText("Please specify people to talk to.");
			else
			{
			writer.println(groupName + " " + mainTextField.getText());
			writer.flush();
			}
			mainTextField.setText("");
			mainTextField.requestFocus();
		}
		else
		{
			writer.println(ChatServer.ALLNAME + " " + mainTextField.getText());
			writer.flush();
			mainTextField.setText("");
			mainTextField.requestFocus();
		}
	}
	
	@FXML
	public void talkTo(ActionEvent event) {
		// TODO Autogenerated
		
		//TODO check for proper syntax
		String people = addressBox.getText();
		addressBox.setText("");
		addressBox.requestFocus();
		writer.println(ChatClient.COMMANDSTART + " startconv " + people);
		writer.flush();
	}
	
	@FXML
	public void updateUserList(Event event)
	{
		writer.println(ChatClient.COMMANDSTART + " getOnlineUsers ");
		writer.flush();
	}
	
	public void initalizeUserList()
	{
		writer.println(ChatClient.COMMANDSTART + " getOnlineUsers ");
		writer.flush();
	}
	
	public TextArea getTA()
	{
		return mainArea;
	}
	
	public VBox getTextFlow()
	{
		return viewTextFlow;
	}
	
	public boolean currentlyPrivate()
	{
		return inGroup;
	}
	
	public void setGroup(String s)
	{
		if(!chats.containsKey(s))
		{
			addTab(s);
		}
	}
	
	public void newTab()
	{
		Tab newChat = new Tab();
	}
	
	public void setMainTextField(TextField f)
	{
		mainTextField = f;
	}
	
	public void setMainArea(TextArea a)
	{
		mainArea = a;
	}
	
	public PrintWriter getWriter()
	{
		return writer;
	}
	
	public void addTab(String s)
	{
		FXMLLoader loader = new FXMLLoader();
		loader.setLocation(ClientMain.class.getResource("ChatTab.fxml"));
		ChatTabController tc = new ChatTabController(this, s);
		loader.setController(tc);
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				try {
					Tab temp = (Tab)loader.load();
					temp.setText(s);
					chatTabPane.getTabs().add(temp);
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
		});
		
		chats.put(s, tc);
	}
	
	public void handleMessage(String sender, String recip, String message)
	{
		/*if(viewArea.isEditable())
		{
			viewArea.setEditable(false);
		}*/
		
		if(recip.equals(ChatServer.ALLNAME))
		{
			//viewTextFlow.appendText(sender + ":" + message + "\n");
			addTextTextFlow(viewTextFlow, message + "\n", scrollText, sender, recip);
			
		}
		else if(chats.containsKey(recip))
		{
			ChatTabController tc = chats.get(recip);
			addTextTextFlow(tc.getTF(), message + "\n", tc.getSP(), sender, recip);
		}
	}
	
	public void updateOnlineTab(String m)
	{
		if(userList.isEditable())
		{
			userList.setEditable(false);
		}
		userList.clear();
		int count = 0;
		Scanner scan = new Scanner(m);
		while(scan.hasNext())
		{
			userList.appendText(scan.next() + " \n");
			count++;
		}
		int refCount = count;
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				onlineTab.setText("Online Users (" + refCount + ")");
			}
			
		});
	}
	
	public void addTextTextFlow(VBox t, String m, ScrollPane s, String sender, String recip)
	{	
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				TextFlow tempTF = new TextFlow();
				if(sender == null)
				{
					tempTF.getChildren().add(new Text(m));
					//s.setVvalue(1.0);
					return;
				}
				Text tempSend = new Text(sender + ": ");
	
				tempTF.getChildren().add(tempSend);
				Queue<Object> obs = EmojiOne.getInstance().toEmojiAndText(m);
				while(!obs.isEmpty()) {
					Object ob = obs.poll();
					if(ob instanceof String) {
						Text temp = new Text((String) ob);
						temp.setTextAlignment(TextAlignment.RIGHT);
						tempTF.getChildren().add(new Text((String)ob));
					}
					else if(ob instanceof Emoji) {
						Emoji emoji = (Emoji) ob;
						tempTF.getChildren().add(createEmojiNode(emoji));
					}
				}
				//s.setVvalue(s.getVmax());
				if(sender.equals(ChatClient.getID()))
					tempTF.setTextAlignment(TextAlignment.RIGHT);
				else
					tempTF.setTextAlignment(TextAlignment.LEFT);
				
				t.getChildren().add(tempTF);
				Media sound = new Media(new File("beep_short_on.wav").toURI().toString());
				MediaPlayer play = new MediaPlayer(sound);
				play.play();
			}
			
		});
	}
	
	public void setMainTextFlow(VBox viewTextFlow2)
	{
		mainTextFlow = viewTextFlow2;
	}
	
	public ScrollPane getSP()
	{
		return scrollText;
	}
	
	private Node createEmojiNode(Emoji emoji) {
		StackPane stackPane = new StackPane();
		stackPane.setPadding(new Insets(3));
		ImageView imageView = new ImageView();
		imageView.setFitWidth(25);
		imageView.setFitHeight(25);
		imageView.setImage(ImageCache.getInstance().getImage(getEmojiImagePath(emoji.getHex())));
		stackPane.getChildren().add(imageView);

		Tooltip tooltip = new Tooltip(emoji.getShortname());
		Tooltip.install(stackPane, tooltip);
		stackPane.setCursor(Cursor.HAND);
		stackPane.setOnMouseEntered(e-> {
			stackPane.setStyle("-fx-background-color: #a6a6a6; -fx-background-radius: 3;");
		});
		stackPane.setOnMouseExited(e-> {
			stackPane.setStyle("");
		});
		return stackPane;
	}

	private String getEmojiImagePath(String hexStr) {
		return ImageCache.class.getResource("png_40/" + hexStr + ".png").toExternalForm();
	}
	
	private void addText(String text) {
		Text textNode = new Text(text);
		//textNode.setFont(Font.font(32));
		viewTextFlow.getChildren().add(textNode);
	}
	
	private void emojiSearch(String category)
	{
		if(category.equals(null))
			return;
		HashSet<Emoji> search = new HashSet<Emoji>(EmojiOne.getInstance().search(emojiText.getText()));
		emojiSearchFlow.getChildren().clear();
		Platform.runLater(new Runnable(){
			@Override
			public void run() {
				// TODO Auto-generated method stub
				for(Emoji em : allEmojis.get(category))
				{
					if(emojiOverlap(search, em))
					{
						Node temp = createEmojiNode(em);
						temp.setOnMouseClicked(e -> {
							mainTextField.appendText(em.getShortname());
						});
						emojiSearchFlow.getChildren().add(temp);
					}
				}
			}
			
		});
	}
	
	private boolean emojiOverlap(HashSet<Emoji> li, Emoji e)
	{
		for(Emoji em : li)
		{
			if(em.getShortname().equals(e.getShortname()))
				return true;
		}
		return false;
	}
}
